<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <title>–ö–∞—Ä—Ç–∞ —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –¥–ª–∏–Ω–Ω—ã—Ö —Å—Å—ã–ª–æ–∫</title>
    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- CodeMirror -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.css">
    <style>
        /* ... (—Å—Ç–∏–ª–∏ –æ—Å—Ç–∞–≤—å—Ç–µ —Ç–∞–∫–∏–º–∏ –∂–µ, –∫–∞–∫ –≤ –ø—Ä–µ–¥—ã–¥—É—â–µ–π –≤–µ—Ä—Å–∏–∏) ... */
    </style>
</head>
<body>
    <div id="map"></div>
    <div class="mouse-coordinates" id="mouse-coords">–®–∏—Ä–æ—Ç–∞: --, –î–æ–ª–≥–æ—Ç–∞: --</div>
    <div class="copy-notification" id="copyNotification">–°—Å—ã–ª–∫–∞ —Å–∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∞!</div>

    <div id="dynamic-ui"></div>

    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.2/codemirror.min.js"></script>

    <script>
        (function() {
            const map = L.map('map', { attributionControl: false }).setView([55.5, 37.5], 5);

            // --- –°–µ—Ç–∫–∞ ---
            function createGraticule() {
                const lines = [];
                for (let lat = -80; lat <= 80; lat += 10) {
                    const points = [];
                    for (let lng = -180; lng <= 180; lng += 5) points.push([lat, lng]);
                    lines.push(L.polyline(points, { color: '#666', weight: 0.5, opacity: 0.3, interactive: false }));
                }
                for (let lng = -180; lng <= 180; lng += 10) {
                    const points = [];
                    for (let lat = -80; lat <= 80; lat += 5) points.push([lat, lng]);
                    lines.push(L.polyline(points, { color: '#666', weight: 0.5, opacity: 0.3, interactive: false }));
                }
                return L.layerGroup(lines);
            }
            createGraticule().addTo(map);

            // --- –ö–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –º—ã—à–∏ ---
            const mouseCoordsDiv = document.getElementById('mouse-coords');
            map.on('mousemove', function(e) {
                mouseCoordsDiv.innerHTML = `–®–∏—Ä–æ—Ç–∞: ${e.latlng.lat.toFixed(5)}, –î–æ–ª–≥–æ—Ç–∞: ${e.latlng.lng.toFixed(5)}`;
            });

            // --- –ü–æ–¥–ª–æ–∂–∫–∏ ---
            const osm = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap' });
            const humanitarian = L.tileLayer('https://{s}.tile.openstreetmap.fr/hot/{z}/{x}/{y}.png', { attribution: '¬© OpenStreetMap, Humanitarian' });
            const cartoDB = L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', { attribution: '¬© OpenStreetMap, CartoDB' });
            const cartoDBDark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', { attribution: '¬© OpenStreetMap, CartoDB' });
            const satellite = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', { attribution: '¬© Esri' });

            osm.addTo(map);
            L.control.layers({
                "üó∫Ô∏è OpenStreetMap": osm,
                "üåç Humanitarian": humanitarian,
                "üöÄ CartoDB Voyager": cartoDB,
                "üåô CartoDB Dark": cartoDBDark,
                "üõ∞Ô∏è Esri Satellite": satellite
            }, null, { position: 'topright', collapsed: false }).addTo(map);
            L.control.attribution({ prefix: false }).addTo(map);

            const markerLayer = L.layerGroup().addTo(map);
            const polylineLayer = L.layerGroup().addTo(map);

            // --- –£–ù–ò–í–ï–†–°–ê–õ–¨–ù–ê–Ø –§–£–ù–ö–¶–ò–Ø –ü–†–ï–û–ë–†–ê–ó–û–í–ê–ù–ò–Ø DMS (–ø–æ–¥–¥–µ—Ä–∂–∫–∞ 4,5,6,7 —Ü–∏—Ñ—Ä) ---
            function dmsToDecimal(digits, dir) {
                const len = digits.length;
                let deg, min, sec = 0;

                if (len === 4 || len === 6) {
                    deg = parseInt(digits.slice(0, 2), 10);
                    min = parseInt(digits.slice(2, 4), 10);
                    if (len === 6) sec = parseInt(digits.slice(4, 6), 10);
                } else if (len === 5 || len === 7) {
                    deg = parseInt(digits.slice(0, 3), 10);
                    min = parseInt(digits.slice(3, 5), 10);
                    if (len === 7) sec = parseInt(digits.slice(5, 7), 10);
                } else {
                    throw new Error(`–ù–µ–≤–µ—Ä–Ω–∞—è –¥–ª–∏–Ω–∞ —á–∏—Å–ª–∞: ${digits}`);
                }

                let decimal = deg + min / 60 + sec / 3600;
                if (dir === 'S' || dir === '–Æ' || dir === 'W' || dir === '–ó') decimal = -decimal;
                return decimal;
            }

            // --- –ü–ê–†–°–ï–† –°–¢–†–û–ö–ò (—Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π –ª–∞—Ç–∏–Ω—Å–∫–∏—Ö C –∏ B) ---
            function parseCoordinatesFromLine(line) {
                const replacements = {
                    '–°':'N', '—Å':'N',
                    '–Æ':'S', '—é':'S',
                    '–í':'E', '–≤':'E',
                    '–ó':'W', '–∑':'W'
                };
                let str = line.replace(/[–°—Å–Æ—é–í–≤–ó–∑]/g, m => replacements[m]);

                str = str.replace(/C/g, 'N').replace(/c/g, 'n')
                         .replace(/B/g, 'E').replace(/b/g, 'e');

                str = str.toUpperCase();
                str = str.replace(/\s+/g, '');

                const tokenPattern = /([NSEW])?(\d{4,7})([NSEW])?/g;
                const tokens = [];
                let match;
                while ((match = tokenPattern.exec(str)) !== null) {
                    const before = match[1];
                    const digits = match[2];
                    const after = match[3];
                    const dir = after || before;
                    if (!dir) continue;
                    tokens.push({ digits, dir });
                }

                const points = [];
                let latToken = null;
                for (let token of tokens) {
                    const d = token.dir;
                    if ((d === 'N' || d === 'S') && latToken === null) {
                        latToken = token;
                    } else if ((d === 'E' || d === 'W') && latToken !== null) {
                        try {
                            const lat = dmsToDecimal(latToken.digits, latToken.dir);
                            const lng = dmsToDecimal(token.digits, token.dir);
                            points.push({
                                lat, lng,
                                original: `${latToken.digits}${latToken.dir} ${token.digits}${token.dir}`
                            });
                        } catch (e) {}
                        latToken = null;
                    } else {
                        latToken = null;
                    }
                }
                return points;
            }

            // --- –ê–Ω–∞–ª–∏–∑ –≤—Å–µ–≥–æ —Ç–µ–∫—Å—Ç–∞ (–¥–ª—è –ø–æ–¥—Å–≤–µ—Ç–∫–∏) ---
            function parseAllLines(text) {
                const lines = text.split(/\r?\n/);
                const allPoints = [], polylines = [];
                for (let i = 0; i < lines.length; i++) {
                    const line = lines[i].trim();
                    if (!line) continue;
                    const pts = parseCoordinatesFromLine(line);
                    if (pts.length === 0) continue;
                    pts.forEach(p => allPoints.push({ ...p, lineIndex: i }));
                    if (pts.length >= 2) polylines.push(pts.map(p => [p.lat, p.lng]));
                }
                return { allPoints, polylines };
            }

            // --- –û—Ç–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Ç–æ—á–µ–∫ –∏ –ª–∏–Ω–∏–π –Ω–∞ –∫–∞—Ä—Ç–µ ---
            function displayPointsAndLines(allPoints, polylines, withPopup = true, onClick = null) {
                markerLayer.clearLayers();
                polylineLayer.clearLayers();
                allPoints.forEach((p, idx) => {
                    const m = L.marker([p.lat, p.lng]).addTo(markerLayer);
                    if (withPopup) {
                        let popup = `<b>–¢–æ—á–∫–∞ ${idx+1}</b><br>${p.original}`;
                        if (p.lineIndex !== undefined) popup += `<br>–°—Ç—Ä–æ–∫–∞ ${p.lineIndex+1}`;
                        m.bindPopup(popup);
                    }
                    if (onClick) m.on('click', () => onClick(p));
                });
                polylines.forEach(latlngs => L.polyline(latlngs, { color: '#3388ff', weight: 3 }).addTo(polylineLayer));
                if (allPoints.length) {
                    const bounds = markerLayer.getBounds();
                    bounds.isValid() ? map.fitBounds(bounds, { padding: [30,30] }) : map.setView([allPoints[0].lat, allPoints[0].lng], 10);
                }
            }

            // --- –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Ä–µ–∂–∏–º–∞: —á–∏—Ç–∞–µ–º –¥–∞–Ω–Ω—ã–µ –∏–∑ –•–ï–®–ê (–µ—Å–ª–∏ –µ—Å—Ç—å) ---
            let dataParam = null;
            if (window.location.hash) {
                const hash = window.location.hash.substring(1); // —É–±–∏—Ä–∞–µ–º '#'
                if (hash.startsWith('data=')) {
                    dataParam = hash.substring(5); // –ø–æ–ª—É—á–∞–µ–º –∑–Ω–∞—á–µ–Ω–∏–µ
                }
            }

            if (dataParam) {
                // –†–ï–ñ–ò–ú –ü–†–û–°–ú–û–¢–†–ê
                document.getElementById('dynamic-ui').innerHTML = '<div class="viewer-note">üîí –†–µ–∂–∏–º –ø—Ä–æ—Å–º–æ—Ç—Ä–∞ (—Ç–æ–ª—å–∫–æ —á—Ç–µ–Ω–∏–µ)</div>';
                try {
                    const decoded = decodeURIComponent(escape(atob(dataParam)));
                    const { allPoints, polylines } = parseAllLines(decoded);
                    displayPointsAndLines(allPoints, polylines, true, (p) => map.panTo([p.lat, p.lng]));
                } catch (e) {
                    console.error(e);
                    document.getElementById('dynamic-ui').innerHTML += '<div style="position:fixed; top:80px; right:20px; background:red; color:white; padding:10px;">–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏</div>';
                }
            } else {
                // –†–ï–ñ–ò–ú –†–ï–î–ê–ö–¢–ò–†–û–í–ê–ù–ò–Ø
                const ui = document.getElementById('dynamic-ui');
                ui.innerHTML = `
                    <div class="control-panel" id="controlPanel">
                        <div class="panel-header" id="panelHeader">
                            üó∫Ô∏è –í–≤–æ–¥ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç (–∑–µ–ª—ë–Ω—ã–π = –æ–∫, –∫—Ä–∞—Å–Ω—ã–π = –æ—à–∏–±–∫–∞)
                            <span>(–ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ)</span>
                        </div>
                        <textarea id="coordsInput" placeholder="–í–≤–µ–¥–∏—Ç–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã..."></textarea>
                        <div class="button-group">
                            <button id="showMapBtn">–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞ –∫–∞—Ä—Ç–µ</button>
                            <button id="shareBtn">üîó –°–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å —Å—Å—ã–ª–∫—É</button>
                        </div>
                        <div class="stats" id="stats">–í–≤–µ–¥–∏—Ç–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –∏ –Ω–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É</div>
                        <div class="note">
                            ‚úÖ GGMM(SS) –∏ GGGMM(SS) –¥–ª—è —à–∏—Ä–æ—Ç—ã –∏ –¥–æ–ª–≥–æ—Ç—ã, –±—É–∫–≤—ã –¥–æ/–ø–æ—Å–ª–µ, —Ä—É—Å/–ª–∞—Ç, C/B<br>
                            ‚úÖ –ö–ª–∏–∫ –ø–æ –º–∞—Ä–∫–µ—Ä—É ‚Üí —Ü–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ + –≤—ã–¥–µ–ª–µ–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏<br>
                            ‚úÖ –î–ª–∏–Ω–Ω—ã–µ —Å—Å—ã–ª–∫–∏ —Ç–µ–ø–µ—Ä—å —Ä–∞–±–æ—Ç–∞—é—Ç (–¥–∞–Ω–Ω—ã–µ –≤ —Ö–µ—à–µ)
                        </div>
                        <div class="drag-hint">‚ÜñÔ∏è –º–æ–∂–Ω–æ –ø–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞—Ç—å</div>
                    </div>
                `;

                const textarea = document.getElementById('coordsInput');
                const editor = CodeMirror.fromTextArea(textarea, {
                    lineNumbers: true,
                    mode: 'text/plain',
                    theme: 'default',
                    indentUnit: 4,
                    autofocus: true
                });

                function analyzeText(text) {
                    return text.split(/\r?\n/).map(line => {
                        const trimmed = line.trim();
                        if (!trimmed) return { valid: true, points: [] };
                        const pts = parseCoordinatesFromLine(trimmed);
                        return { valid: pts.length > 0, points: pts };
                    });
                }

                function highlightLines() {
                    const text = editor.getValue();
                    const results = analyzeText(text);
                    editor.getAllMarks().forEach(m => m.clear());
                    for (let i = 0; i < results.length; i++) {
                        const line = editor.getLine(i);
                        if (!line.trim()) continue;
                        editor.markText({ line: i, ch: 0 }, { line: i, ch: line.length }, {
                            className: results[i].valid ? 'valid-line' : 'invalid-line',
                            inclusiveLeft: true, inclusiveRight: true
                        });
                    }
                }

                const style = document.createElement('style');
                style.innerHTML = `.valid-line{background-color:#d4edda!important}.invalid-line{background-color:#f8d7da!important}`;
                document.head.appendChild(style);

                let timeout;
                editor.on('change', () => {
                    clearTimeout(timeout);
                    timeout = setTimeout(highlightLines, 300);
                });

                document.getElementById('showMapBtn').addEventListener('click', function() {
                    const text = editor.getValue();
                    const results = analyzeText(text);
                    const errorLines = results.map((r,i) => ({ valid: r.valid, idx: i+1, text: editor.getLine(i) }))
                        .filter(r => !r.valid && r.text.trim()).map(r => r.idx);
                    const stats = document.getElementById('stats');

                    const allPoints = [], polylines = [];
                    for (let i = 0; i < results.length; i++) {
                        if (!results[i].valid) continue;
                        const line = editor.getLine(i);
                        if (!line.trim()) continue;
                        const pts = parseCoordinatesFromLine(line);
                        pts.forEach(p => allPoints.push({ ...p, lineIndex: i }));
                        if (pts.length >= 2) polylines.push(pts.map(p => [p.lat, p.lng]));
                    }

                    let msg = allPoints.length ? `‚úÖ –¢–æ—á–µ–∫: ${allPoints.length}, –ª–∏–Ω–∏–π: ${polylines.length}` : '‚ö†Ô∏è –ù–µ—Ç –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã—Ö –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç.';
                    if (errorLines.length) msg += `<br><span class="error-list">‚ùå –û—à–∏–±–∫–∞ –≤ —Å—Ç—Ä–æ–∫–µ(–∞—Ö): ${errorLines.join(', ')}</span>`;
                    stats.innerHTML = msg;

                    if (allPoints.length) {
                        displayPointsAndLines(allPoints, polylines, true, (p) => {
                            map.panTo([p.lat, p.lng]);
                            editor.setSelection({ line: p.lineIndex, ch: 0 }, { line: p.lineIndex, ch: editor.getLine(p.lineIndex).length });
                            editor.scrollIntoView({ line: p.lineIndex, ch: 0 });
                            editor.focus();
                        });
                    } else {
                        markerLayer.clearLayers();
                        polylineLayer.clearLayers();
                    }
                });

                // --- –ö–Ω–æ–ø–∫–∞ –∫–æ–ø–∏—Ä–æ–≤–∞–Ω–∏—è —Å—Å—ã–ª–∫–∏ (—Ç–µ–ø–µ—Ä—å —Å —Ö–µ—à–µ–º) ---
                document.getElementById('shareBtn').addEventListener('click', function() {
                    const text = editor.getValue();
                    if (!text.trim()) {
                        alert('–í–≤–µ–¥–∏—Ç–µ –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–µ—Ä–µ–¥ —Å–æ–∑–¥–∞–Ω–∏–µ–º —Å—Å—ã–ª–∫–∏.');
                        return;
                    }
                    const encoded = btoa(unescape(encodeURIComponent(text)));
                    const url = new URL(window.location.href);
                    url.hash = 'data=' + encoded; // —Å–æ—Ö—Ä–∞–Ω—è–µ–º –≤ —Ö–µ—à
                    navigator.clipboard.writeText(url.toString()).then(() => {
                        const notif = document.getElementById('copyNotification');
                        notif.classList.add('show');
                        setTimeout(() => notif.classList.remove('show'), 2000);
                    }).catch(() => {
                        alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–æ–ø–∏—Ä–æ–≤–∞—Ç—å, –≤–æ—Ç —Å—Å—ã–ª–∫–∞:\n' + url.toString());
                    });
                });

                // –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–Ω–∏–µ –ø–∞–Ω–µ–ª–∏
                const panel = document.getElementById('controlPanel');
                const header = document.getElementById('panelHeader');
                let dragging = false, offsetX, offsetY;
                header.addEventListener('mousedown', (e) => {
                    dragging = true;
                    offsetX = e.clientX - panel.offsetLeft;
                    offsetY = e.clientY - panel.offsetTop;
                    panel.style.cursor = 'grabbing';
                });
                document.addEventListener('mousemove', (e) => {
                    if (!dragging) return;
                    e.preventDefault();
                    panel.style.left = (e.clientX - offsetX) + 'px';
                    panel.style.top = (e.clientY - offsetY) + 'px';
                });
                document.addEventListener('mouseup', () => {
                    dragging = false;
                    panel.style.cursor = 'move';
                });

                setTimeout(highlightLines, 100);
            }
        })();
    </script>
</body>
</html>
